<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Lintian::Tutorial::WritingChecks</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script type="text/javascript" src="<script type="text/javascript" src="../../_podly.js"></script>
"></script>
</head>
<body>


<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Create-a-check-.desc-file">Create a check .desc file</a></li>
      <li><a href="#Create-the-Perl-check-module">Create the Perl check module</a></li>
      <li><a href="#Accessing-fields">Accessing fields</a></li>
      <li><a href="#Checking-dependencies">Checking dependencies</a></li>
      <li><a href="#Using-static-data-files">Using static data files</a></li>
      <li><a href="#Accessing-contents-of-the-package">Accessing contents of the package</a>
        <ul>
          <li><a href="#Accessing-contents-of-a-file-in-a-package">Accessing contents of a file in a package</a></li>
        </ul>
      </li>
      <li><a href="#Keeping-Needs-Info-up-to-date">Keeping Needs-Info up to date</a></li>
      <li><a href="#Avoiding-security-issues">Avoiding security issues</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Lintian::Tutorial::WritingChecks -- Writing checks for Lintian</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>Warning: This tutorial may be outdated.</p>

<p>This guide will quickly guide you through the basics of writing a Lintian check. Most of the work is in writing the two files:</p>

<pre><code>  checks/&lt;my-check&gt;.pm
  checks/&lt;my-check&gt;.desc</code></pre>

<p>And then either adding a Lintian profile or extending an existing one.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The basics of writing a check are outlined in the Lintian User Manual (§3.3). This tutorial will focus on the act of writing the actual check. In this tutorial, we will assume the name of the check to be written is &quot;deb/pkg-check&quot;.</p>

<p>The tutorial will work with a &quot;binary&quot; and &quot;udeb&quot; check. Checking source packages works in a similar fashion.</p>

<h2 id="Create-a-check-.desc-file">Create a check <i>.desc</i> file</h2>

<p>As mentioned, this tutorial will focus on the writing of a check. Please see the Lintian User Manual (§3.3) for how to do this part.</p>

<h2 id="Create-the-Perl-check-module">Create the Perl check module</h2>

<p>Start with the template:</p>

<pre><code> # deb/pkg-check is loaded as Lintian::deb::pkg_check
 # - See Lintian User Manual §3.3 for more info
 package Lintian::deb::pkg_check;

 use strict;
 use warnings;
 
 sub run {
     my ($pkg, $type, $info, $proc, $group) = @_;
     return;
 }</code></pre>

<p>The snippet above is a simple valid check that does &quot;nothing at all&quot;. We will extend it in just a moment, but first let us have a look at the arguments at the setup.</p>

<p>The <i>run</i> sub is the entry point of our &quot;deb/pkg-check&quot; check; it will be invoked once per package it should process. In our case, that will be once per &quot;binary&quot; (.deb) and once per udeb package processed.</p>

<p>It is given 5 arguments (in the future, possibly more), which are:</p>

<dl>

<dt>$pkg - The name of the package being processed.</dt>
<dd>

<p>(Same as $proc-&gt;pkg_name)</p>

</dd>
<dt>$type - The type of the package being processed.</dt>
<dd>

<p>At the moment, $type is one of &quot;binary&quot; (.deb), &quot;udeb&quot;, &quot;source&quot; (.dsc) or &quot;changes&quot;. This argument is mostly useful if certain checks do not apply equally to all package types being processed.</p>

<p>Generally it is advisable to check only binaries (&quot;binary&quot; and &quot;udeb&quot;), sources or changes in a given check. But in rare cases, it makes sense to lump multiple types together in the same check and this argument helps you do that.</p>

<p>(Current it is always identical to $proc-&gt;pkg_type)</p>

</dd>
<dt>$info - Accessor to the data Lintian has extracted</dt>
<dd>

<p>Basically all information you want about a given package comes from the $info object. Sometimes referred to as either the &quot;info object&quot; or (an instance of) <a href="https://metacpan.org/pod/Lintian::Collect">Lintian::Collect</a>.</p>

<p>This object (together with a properly set Needs-Info in the <i>.desc</i> file) will grant you access to all of the data Lintian has extracted about this package.</p>

<p>Based on the value of the $type argument, it will be one of <a href="https://metacpan.org/pod/Lintian::Collect::Binary">Lintian::Collect::Binary</a>, <a href="https://metacpan.org/pod/Lintian::Collect::Changes">Lintian::Collect::Changes</a> or <a href="https://metacpan.org/pod/Lintian::Collect::Source">Lintian::Collect::Source</a>.</p>

<p>(Currently it is the same as $proc-&gt;info)</p>

</dd>
<dt>$proc - Basic metadata about the package</dt>
<dd>

<p>This is an instance of <a href="https://metacpan.org/pod/Lintian::Processable">Lintian::Processable</a> and is useful for trivially obtaining very basic package metadata. Particularly, the name of source package and version of source package are readily available through this object.</p>

</dd>
<dt>$group - Group of processables from the same source</dt>
<dd>

<p>If you want to do a cross-check between different packages built from the same source, $group helps you access those other packages (if they are available).</p>

<p>This is an instance of <a href="https://metacpan.org/pod/Lintian::ProcessableGroup">Lintian::ProcessableGroup</a>.</p>

</dd>
</dl>

<p>Now back to the coding.</p>

<h2 id="Accessing-fields">Accessing fields</h2>

<p>Let&#39;s do a slightly harder example. Assume we wanted to emit a tag for all packages without a (valid) Multi-Arch field. This requires us to A) identify if the package has a Multi-Arch field and B) identify if the content of the field was valid.</p>

<p>Starting from the top. All $info objects have a method called field, which gives you access to a (raw) field from the control file of the package. It returns <code>undef</code> if said field is not present or the content of said field otherwise. Note that field names must be given in all lowercase letters (i.e. use &quot;multi-arch&quot;, not &quot;Multi-Arch&quot;).</p>

<p>This was the first half. Let&#39;s look at checking the value. Multi-arch fields can (currently) be one of &quot;no&quot;, &quot;same&quot;, &quot;foreign&quot; or &quot;allowed&quot;. One way of checking this would be using the regex:</p>

<p>Notice that Lintian automatically strips leading and trailing spaces on the <i>first</i> line in a field. It also strips trailing spaces from all other lines, but leading spaces and the &quot; .&quot;-continuation markers are kept as is.</p>

<h2 id="Checking-dependencies">Checking dependencies</h2>

<p>Lintian can do some checking of dependencies. For most cases it works similar to a normal dependency check, but keep in mind that Lintian uses <i>pure</i> logic to determine if dependencies are satisfied (i.e. it will not look up relations like Provides for you).</p>

<p>Suppose you wanted all packages with a multi-arch &quot;same&quot; field to pre-depend on the package &quot;multiarch-support&quot;. Well, we could use the <a href="https://metacpan.org/pod/Lintian::Collect::Binary#relation-FIELD">$info-&gt;relation</a> method for this.</p>

<p>$info-&gt;relation returns an instance of <a href="https://metacpan.org/pod/Lintian::Relation">Lintian::Relation</a>. This object has an &quot;implies&quot; method that can be used to check if a package has an explicit dependency. Note that &quot;implies&quot; actually checks if one relation &quot;implies&quot; another (i.e. if you satisfied relationA then you definitely also satisfied relationB).</p>

<p>As with the &quot;field&quot;-method, field names have to be given in all lowercase. However &quot;relation&quot; will never return <code>undef</code> (not even if the field is missing).</p>

<h2 id="Using-static-data-files">Using static data files</h2>

<p>Currently our check mixes data and code. Namely all the valid values for the Multi-Arch field are currently hard-coded in our check. We can move those out of the check by using a data file.</p>

<p>Lintian natively supports data files that are either &quot;sets&quot; or &quot;tables&quot; via <a href="https://metacpan.org/pod/Lintian::Data">Lintian::Data</a> (i.e. &quot;unordered&quot; collections). As an added bonus, <a href="https://metacpan.org/pod/Lintian::Data">Lintian::Data</a> transparently supports vendor specific data files for us.</p>

<p>First we need to make a data file containing the values. Which could be:</p>

<pre><code> # A table of all the valid values for the multi-arch field.
 no
 same
 foreign
 allowed</code></pre>

<p>This can then be stored in the data directory as <i>data/deb/pkg-check/multiarch-values</i>.</p>

<p>Now we can load it by using:</p>

<pre><code> use Lintian::Data;
 
 my $VALID_MULTI_ARCH_VALUES =
     Lintian::Data-&gt;new(&#39;deb/pkg-check/multiarch-values&#39;);</code></pre>

<p>Actually, this is not quite true. <a href="https://metacpan.org/pod/Lintian::Data">Lintian::Data</a> is lazy, so it will not load anything before we force it to do so. Most of the time this is just an added bonus. However, if you ever have to force it to load something immediately, you can do so by invoking its &quot;known&quot; method (with an arbitrary defined string and ignore the result).</p>

<p>Data files work with 3 access methods, &quot;all&quot;, &quot;known&quot; and &quot;value&quot;.</p>

<dl>

<dt>all</dt>
<dd>

<p>&quot;all&quot; (i.e. $data-&gt;all) returns a list of all the entries in the data file (for key/value tables, all returns the keys). The list is not sorted in any order (not even input order).</p>

</dd>
<dt>known</dt>
<dd>

<p>&quot;known&quot; (i.e. $data-&gt;known(&#39;item&#39;)) returns a truth value if a given item or key is known (present) in the data set or table. For key/pair tables, the value associated with the key can be retrieved with &quot;value&quot; (see below).</p>

</dd>
<dt>value</dt>
<dd>

<p>&quot;value&quot; (i.e. $data-&gt;value(&#39;key&#39;)) returns a value associated with a key for key/value tables. For unknown keys, it returns <code>undef</code>. If the data file is not a key/value table but just a set, value returns a truth value for known keys.</p>

</dd>
</dl>

<p>While we could use both &quot;value&quot; and &quot;known&quot;, we will use the latter for readability (and to remind ourselves that this is a data set and not a data table).</p>

<p>Basically we will be replacing:</p>

<pre><code>  unless exists $VALID_MULTI_ARCH_VALUES{$multiarch};</code></pre>

<p>with</p>

<pre><code>  unless $VALID_MULTI_ARCH_VALUES-&gt;known($multiarch);</code></pre>

<h2 id="Accessing-contents-of-the-package">Accessing contents of the package</h2>

<p>Another heavily used mechanism is to check for the presence (or absence) of a given file. Generally this is what the <a href="https://metacpan.org/pod/Lintian::Collect::Package#index-FILE">$info-&gt;index</a> and <a href="https://metacpan.org/pod/Lintian::Collect::Package#sorted_index">$info-&gt;sorted_index</a> methods are for. The &quot;index&quot; method returns instances of <a href="https://metacpan.org/pod/Lintian::Path">Lintian::Path</a>, which has a number of utility methods.</p>

<p>If you want to loop over all files in a package, the sorted_index will do this for you. If you are looking for a specific file (or directory), a call to &quot;index&quot; will be much faster. For the contents of a specific directory, you can use something like:</p>

<pre><code> if (my $dir = $info-&gt;index(&#39;path/to/dir/&#39;)) {
     foreach my $elem ($dir-&gt;children) {
         print $elem-&gt;name . &quot; is a file&quot; if $elem-&gt;is_file;
         # ...
     }
 }</code></pre>

<p>Keep in mind that using the &quot;index&quot; or &quot;sorted_index&quot; method will require that you put &quot;unpacked&quot; in Needs-Info. See <a href="#Keeping-Needs-Info-up-to-date">&quot;Keeping Needs-Info up to date&quot;</a>.</p>

<p>There are also a pair of methods for accessing the control files of a binary package. These are <a href="https://metacpan.org/pod/Lintian::Collect::Package#control_index-FILE">$info-&gt;control_index</a> and <a href="https://metacpan.org/pod/Lintian::Collect::Package#sorted_control_index">$info-&gt;sorted_control_index</a>.</p>

<h3 id="Accessing-contents-of-a-file-in-a-package">Accessing contents of a file in a package</h3>

<p>When you actually want to see the contents of a file, you can use <a href="https://metacpan.org/pod/Lintian::Path#open">open</a> (or <a href="https://metacpan.org/pod/Lintian::Path#open_gz">open_gz</a>) on an object returned by e.g. <a href="https://metacpan.org/pod/Lintian::Collect::Package#index-FILE">$info-&gt;index</a>. These methods will open the underlying file for reading (the latter applying a gzip decompression).</p>

<p>However, please do assert that the file is safe to read by calling <a href="https://metacpan.org/pod/Lintian::Path#is_open_ok">is_open_ok</a> first. Generally, it will only be true for files or safely resolvable symlinks pointing to files. Should you attempt to open a path that does not satisfy those criteria, <a href="https://metacpan.org/pod/Lintian::Path">Lintian::Path</a> will raise a trappable error at runtime.</p>

<p>Alternatively, if you access the underlying file object, you can use the <a href="https://metacpan.org/pod/Lintian::Path#fs_path">fs_path</a> method. Usually, you will want to test either <a href="https://metacpan.org/pod/Lintian::Path#is_open_ok">is_open_ok</a> or <a href="https://metacpan.org/pod/Lintian::Path#is_valid_path">is_valid_path</a> first to ensure you do not follow unsafe symlinks. The &quot;is_open_ok&quot; check will also assert that it is not (e.g.) a named pipe or such.</p>

<p>Should you call <a href="https://metacpan.org/pod/Lintian::Path#fs_path">fs_path</a> on a symlink that escapes the package root, the method will throw a trappable error at runtime. Once the path is returned, there are no more built-in fail-safes. When you use the returned path, keep things like &quot;../../../../../etc/passwd&quot;-symlink and &quot;fifo&quot; pipes in mind.</p>

<p>In some cases, you may even need to access the file system objects <i>without</i> using <a href="https://metacpan.org/pod/Lintian::Path">Lintian::Path</a>. This is, of course, discouraged and suffers from the same issues above (all checking must be done manually by you). Here you have to use the &quot;unpacked&quot;, &quot;debfiles&quot; or &quot;control&quot; methods from <a href="https://metacpan.org/pod/Lintian::Collect">Lintian::Collect</a> or its subclasses.</p>

<p>The following snippet may be useful for testing that a given path does not escape the root.</p>

<pre><code> use Lintian::Util qw(is_ancestor_of);
 
 my $path = ...;
 # The snippet applies equally well to $info-&gt;debfiles and
 # $info-&gt;control (just remember to subst all occurrences of
 # $info-&gt;unpacked).
 my $unpacked_file = $info-&gt;unpacked($path);
 if ( -f $unpacked_file &amp;&amp; is_ancestor_of($info-&gt;unpacked, $unpacked_file)) {
    # a file and contained within the package root.
 } else {
    # not a file or an unsafe path
 }</code></pre>

<h2 id="Keeping-Needs-Info-up-to-date">Keeping Needs-Info up to date</h2>

<p>Keeping the &quot;Needs-Info&quot; field of your <i>.desc</i> file is a bit of manual work. In the API description for the method there will generally be a line looking something like:</p>

<pre><code>  Needs-Info requirements for using methodx: Y</code></pre>

<p>Which means that the methodx requires Y to work. Here Y is a comma separated list and each element of Y basically falls into 3 cases.</p>

<ul>

<li><p>The element is the word <i>none</i></p>

<p>In this case, the method has no &quot;external&quot; requirements and can be used without any changes to your Needs-Info. The &quot;field&quot; method is an example of this.</p>

<p>This only makes sense if it is the only element in the list.</p>

</li>
<li><p>The element is a link to a method</p>

<p>In this case, the method uses another method to do its job. An example is the <a href="https://metacpan.org/pod/Lintian::Collect::Binary#sorted_control_index">sorted_control_index</a> method, which uses the <a href="https://metacpan.org/pod/Lintian::Collect::Binary#control_index-FILE">control_index</a> method. So using <i>sorted_control_index</i> has the same requirements as using <i>control_index</i>.</p>

</li>
<li><p>The element is the name of a collection (e.g. &quot;control_index&quot;).</p>

<p>In this case, the method needs the given collection to be run. So to use (e.g.) <a href="https://metacpan.org/pod/Lintian::Collect::Binary#control_index-FILE">control_index</a>, you have to put &quot;bin-pkg-control&quot; in your Needs-Info.</p>

</li>
</ul>

<p>CAVEAT: Methods can have different requirements based on the type of package! An example of this &quot;changelog&quot;, which requires &quot;changelog-file&quot; in binary packages and &quot;Same as debfiles&quot; in source packages.</p>

<h2 id="Avoiding-security-issues">Avoiding security issues</h2>

<p>Over the years a couple of security issues have been discovered in Lintian. The problem is that people can in theory create some really nasty packages. Please keep the following in mind when writing a check:</p>

<ul>

<li><p>Avoid 2-arg open, system/exec($shellcmd), `$shellcmd` like the plague.</p>

<p>When you get any one of those wrong you introduce &quot;arbitrary code execution&quot; vulnerabilities (we learned this the hard way via CVE-2009-4014).</p>

<p>Usually 3-arg open and the non-shell variant of system/exec are enough. When you actually need a shell pipeline, consider using <a href="https://metacpan.org/pod/Lintian::Command">Lintian::Command</a>. It also provides a <i>safe_qx</i> command to assist with capturing stdout as an alternative to `$cmd` (or qx/$cmd/).</p>

</li>
<li><p>Do not trust field values.</p>

<p>This is especially true if you intend to use the value as part of a file name. Verify that the field contains what you expect before you use it.</p>

</li>
<li><p>Use <a href="https://metacpan.org/pod/Lintian::Path">Lintian::Path</a> (or, failing that, is_ancestor_of)</p>

<p>You might be tempted to think that the following code is safe:</p>

<pre><code> use autodie;
 
 my $filename = &#39;some/file&#39;;
 my $ufile = $info-&gt;unpacked($filename);
 if ( ! -l $ufile) {
    # Looks safe, but isn&#39;t in general
    open(my $fd, &#39;&lt;&#39;, $ufile);
    ...;
 }</code></pre>

<p>This is definitely unsafe if &quot;$filename&quot; contains at least one directory segment. So, if in doubt, use <a href="https://metacpan.org/pod/Lintian::Util#is_ancestor_of-PARENTDIR-PATH">is_ancestor_of</a> to verify that the requested file is indeed the file you think it is. A better version of the above would be:</p>

<pre><code> use autodie,
 use Lintian::Util qw(is_ancestor_of);
 [...]
 my $filename = &#39;some/file&#39;;
 my $ufile = $info-&gt;unpacked($filename);
 if ( ! -l $ufile &amp;&amp; -f $ufile &amp;&amp; is_ancestor_of($info-&gt;unpacked, $ufile)) {
    # $ufile is a file and it is contained within the package root.
    open(m $fd, &#39;&lt;&#39;, $ufile);
    ...;
 }</code></pre>

<p>In some cases you can even drop the &quot;! -l $ufile&quot; part.</p>

<p>Of course, it is much easier to use the <a href="https://metacpan.org/pod/Lintian::Path">Lintian::Path</a> object (whenever possible).</p>

<pre><code> my $filename = &#39;some/file&#39;;
 my $ufile = $info-&gt;index($filename);
 if ( $ufile &amp;&amp; $ufile-&gt;is_file &amp;&amp; $ufile-&gt;is_open_ok) {
     my $fd = $ufile-&gt;open;
     ...;
 }</code></pre>

<p>Here you can drop the &quot; &amp;&amp; $ufile-&gt;is_file&quot; if you want to permit safe symlinks.</p>

<p>For more information on the is_ancestor_of check, see <a href="https://metacpan.org/pod/Lintian::Util#is_ancestor_of-PARENTDIR-PATH">is_ancestor_of</a></p>

</li>
</ul>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="https://metacpan.org/pod/Lintian::Tutorial::WritingTests">Lintian::Tutorial::WritingTests</a>, <a href="https://metacpan.org/pod/Lintian::Tutorial::TestSuite">Lintian::Tutorial::TestSuite</a></p>

<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>


